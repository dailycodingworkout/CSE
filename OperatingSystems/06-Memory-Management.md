# Chapter 6: Memory Management

> **"Memory management is like hotel room allocation - efficiently assign rooms (memory) to guests (processes) while avoiding overbooking"**

---

## ğŸ¯ Why Memory Management?

**Goals:**
1. Keep multiple processes in memory (multiprogramming)
2. Maximize CPU utilization and system throughput
3. Protect processes from each other
4. Enable efficient sharing

---

## ğŸ“Š Memory Hierarchy

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚Registersâ”‚  â† Fastest, smallest (bytes)
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ L1 Cacheâ”‚  â† Very fast (KB)
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ L2 Cacheâ”‚  â† Fast (MB)
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ L3 Cacheâ”‚  â† Moderate (MB)
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
     â”‚  Main Memory  â”‚  â† Slower (GB)
     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Disk/SSD      â”‚  â† Slowest, largest (TB)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’¡ Key Trade-off:** Speed â†” Capacity â†” Cost

---

## ğŸ”„ Address Binding

### When Addresses are Bound

| Time | Description | Flexibility |
|------|-------------|-------------|
| **Compile Time** | Absolute code generated | Must recompile to relocate |
| **Load Time** | Relocatable code, addresses fixed at load | Reload to relocate |
| **Execution Time** | Addresses bound during run | Can relocate dynamically |

---

## ğŸ“ Logical vs Physical Address

| Aspect | Logical (Virtual) Address | Physical Address |
|--------|--------------------------|------------------|
| **Generated by** | CPU | Memory unit |
| **Visible to** | Process | Hardware |
| **Range** | Logical address space | Physical address space |
| **Translation** | By MMU | Direct memory access |

### Memory Management Unit (MMU)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   Logical    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   Physical   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CPU   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   MMU   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Memory â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Address     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   Address    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Simplest MMU:** Relocation Register

```
Physical Address = Logical Address + Relocation Register
```

---

## ğŸ”€ Swapping

**Definition:** Move entire process between main memory and disk

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Main Memory  â”‚ â—„â”€â”€â”€â”€â”€â–º â”‚  Backing     â”‚
â”‚  (active)    â”‚  swap   â”‚  Store       â”‚
â”‚              â”‚         â”‚  (disk)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Swap Time:** Proportional to memory size

```
Transfer Time = (Process Size) / (Transfer Rate)

Example:
Process = 100 MB
Rate = 50 MB/s
Time = 2 seconds (each way)
Total swap = 4 seconds
```

---

## ğŸ“¦ Contiguous Memory Allocation

### Single Partition

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Operating System        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                â”‚
â”‚        User Process            â”‚
â”‚                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Protection:** Use limit and relocation registers

```
If (logical address < limit)
    Physical address = logical + relocation
Else
    Trap (addressing error)
```

---

### Multiple Partitions

#### Fixed Partitions (MFT - Multiprogramming with Fixed Tasks)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Operating System        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 1 (100 KB)       â”‚  â† 50KB process â†’ 50KB internal frag
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 2 (200 KB)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 3 (300 KB)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 4 (400 KB)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Internal Fragmentation:** Unused space within allocated partition

---

#### Variable Partitions (MVT - Multiprogramming with Variable Tasks)

```
Initially:                  After allocations:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       OS       â”‚         â”‚       OS       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                â”‚         â”‚    P1 (100K)   â”‚
â”‚    Free        â”‚   â†’     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    (1 MB)      â”‚         â”‚    P2 (200K)   â”‚
â”‚                â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                â”‚         â”‚     Hole       â”‚
â”‚                â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                â”‚         â”‚    P3 (300K)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**External Fragmentation:** Free memory exists but not contiguous

---

### Dynamic Storage Allocation Strategies

| Strategy | Description | Speed | Utilization |
|----------|-------------|-------|-------------|
| **First Fit** | Allocate first hole large enough | Fast | Good |
| **Best Fit** | Allocate smallest hole that's large enough | Slow | Good |
| **Worst Fit** | Allocate largest hole | Slow | Poor |
| **Next Fit** | First fit from last allocation position | Fast | Medium |

**ğŸ’¡ GATE Insight:** First Fit and Best Fit are better than Worst Fit in practice

**50% Rule:** Given N allocated blocks, approximately 0.5N blocks are lost to fragmentation (for First Fit)

---

### Compaction

**Solution to External Fragmentation:** Shuffle memory to place all free memory together

```
Before Compaction:          After Compaction:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       OS       â”‚         â”‚       OS       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      P1        â”‚         â”‚      P1        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     HOLE       â”‚         â”‚      P2        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      P2        â”‚  â†’      â”‚      P3        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     HOLE       â”‚         â”‚                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚   Large Hole   â”‚
â”‚      P3        â”‚         â”‚                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚                â”‚
â”‚     HOLE       â”‚         â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Requirements:**
- Dynamic relocation (execution-time binding)
- All references must be relocatable

**Cost:** High I/O and CPU overhead

---

## ğŸ“‘ Paging

### Concept

**Break physical memory and logical memory into fixed-size blocks:**
- Physical: Frames
- Logical: Pages

```
Logical Memory (Pages)        Physical Memory (Frames)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Page 0      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â–º   Frame 1     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Page 1      â”‚â”€â”€â”€â”€â”€â”€â”    â”‚    Frame 0     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Page 2      â”‚â”€â”€â”€â”  â””â”€â”€â”€â”€â”¤â–º   Frame 4     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Page 3      â”‚â”€â” â”‚       â”‚    Frame 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”¤â–º   Frame 3     â”‚
                   â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â–º   Frame 5     â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Benefits:**
- No external fragmentation
- Easy to allocate (any free frame)
- Process doesn't need contiguous memory

**Cost:**
- Internal fragmentation (last page)
- Page table overhead

---

### Address Translation

**Logical Address = (Page Number, Page Offset)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Logical Address                       â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚  Page Number (p)â”‚ Offset (d)   â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚          â”‚                â”‚           â”‚
â”‚          â–¼                â”‚           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚           â”‚
â”‚    â”‚Page Table â”‚          â”‚           â”‚
â”‚    â”‚    p      â”‚â”€â”€â”       â”‚           â”‚
â”‚    â”‚    ...    â”‚  â”‚       â”‚           â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚       â”‚           â”‚
â”‚                   â–¼       â–¼           â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚ Frame Number (f)â”‚ Offset (d)   â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚ Physical Address                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Formulas:**

```
Page Size = 2^d bytes (d = offset bits)
Number of Pages = 2^p (p = page number bits)
Logical Address Space = 2^(p+d) bytes

Frame Number = Page Table[Page Number]
Physical Address = (Frame Number Ã— Page Size) + Offset
```

---

### Page Table Entry (PTE)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ V â”‚ R â”‚ M â”‚ Prot â”‚     Frame Number                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†‘   â†‘   â†‘    â†‘
  â”‚   â”‚   â”‚    â””â”€â”€ Protection bits (RWX)
  â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€ Modified/Dirty bit
  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Referenced/Accessed bit
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Valid/Invalid bit
```

| Bit | Purpose |
|-----|---------|
| **Valid (V)** | Is page in memory? |
| **Reference (R)** | Has page been accessed? |
| **Modified (M)** | Has page been written? |
| **Protection** | Read/Write/Execute permissions |

---

### Example Calculation

**Given:**
- Logical Address Space = 64 KB = 2^16 bytes
- Page Size = 4 KB = 2^12 bytes
- Physical Memory = 256 KB = 2^18 bytes

```
Page number bits (p) = 16 - 12 = 4 bits
Offset bits (d) = 12 bits
Number of Pages = 2^4 = 16 pages

Frame number bits = 18 - 12 = 6 bits
Number of Frames = 2^6 = 64 frames

Page Table Entries = 16
Page Table Size = 16 Ã— (size of each entry)
                = 16 Ã— 6 bits (minimum) or rounded to bytes
```

---

### Page Table Implementation

#### Basic: Page Table in Memory

**Problem:** Two memory accesses per data access (one for page table, one for data)

**Effective Access Time (EAT):**
```
EAT = 2 Ã— Memory Access Time
```

---

#### Translation Look-aside Buffer (TLB)

**Solution:** Hardware cache for page table entries

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CPU                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚  â”‚ Logical Addrâ”‚                                      â”‚
â”‚  â”‚   p | d     â”‚                                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â”‚         â”‚                                             â”‚
â”‚         â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    TLB Hit    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    TLB      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Frame Number    â”‚   â”‚
â”‚  â”‚  (fast)     â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                        â”‚            â”‚
â”‚         â”‚ TLB Miss                      â”‚            â”‚
â”‚         â–¼                               â”‚            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚            â”‚
â”‚  â”‚ Page Table  â”‚                        â”‚            â”‚
â”‚  â”‚  (memory)   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚            â”‚
â”‚                                         â–¼            â”‚
â”‚                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚                              â”‚ Physical Address   â”‚  â”‚
â”‚                              â”‚    f | d           â”‚  â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**TLB Hit Ratio (Î±):** Probability of finding page in TLB

```
EAT = Î± Ã— (TLB Access + Memory Access) + 
      (1-Î±) Ã— (TLB Access + 2 Ã— Memory Access)

Simplified (if TLB access time negligible):
EAT = Î± Ã— m + (1-Î±) Ã— 2m = m(2 - Î±)

where m = memory access time
```

**Example:**
```
TLB access = 10 ns
Memory access = 100 ns
Hit ratio = 99%

EAT = 0.99 Ã— (10 + 100) + 0.01 Ã— (10 + 200)
    = 0.99 Ã— 110 + 0.01 Ã— 210
    = 108.9 + 2.1
    = 111 ns

Compare to no TLB: 200 ns
Speedup: 200/111 â‰ˆ 1.8Ã—
```

---

### ASID (Address Space Identifier)

**Problem:** Each process has its own page table; TLB entries become invalid on context switch

**Solution:** ASID tags each TLB entry with process ID
- No TLB flush on context switch
- Match both page number AND ASID

---

### Page Table Structures

#### 1. Hierarchical (Multi-level) Paging

**Problem:** Large page tables (32-bit address, 4KB page â†’ 1M entries â†’ 4MB table)

**Solution:** Page the page table!

**Two-Level Paging:**
```
32-bit address, 4KB pages:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  p1 (10 bits)â”‚  p2 (10 bits)â”‚ offset (12 bits)â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚              â”‚                â”‚
       â–¼              â–¼                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚Outer Page Tblâ”‚â”€â–ºâ”‚Inner Page Tblâ”‚â”€â”€â”€â”€â”€â”¼â”€â”€â–º Physical Addr
â”‚   (1 entry)  â”‚ â”‚   (1 entry)  â”‚      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
                                       â”‚
                                       â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚  f | offset         â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**64-bit Systems:** 4-level (PGD â†’ PUD â†’ PMD â†’ PTE)

---

#### 2. Hashed Page Tables

**For sparse address spaces:**

```
Page Number â†’ Hash Function â†’ Hash Table Index

Hash Table Entry: (page number, frame number, next pointer)

On collision, chain entries
```

**Clustered Page Tables:** Each entry covers range of pages

---

#### 3. Inverted Page Tables

**Idea:** One entry per frame (not per page)

```
Instead of: Page Table [page number] â†’ frame number
Use:        Inverted Table [frame number] â†’ (PID, page number)
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Logical Address                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   PID   â”‚   Page No  â”‚   Offset   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚          â”‚            â”‚               â”‚
â”‚       â–¼          â–¼            â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚               â”‚
â”‚  â”‚ Search Inverted    â”‚       â”‚               â”‚
â”‚  â”‚ Page Table for     â”‚       â”‚               â”‚
â”‚  â”‚ (PID, Page No)     â”‚       â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚               â”‚
â”‚            â”‚                  â”‚               â”‚
â”‚            â–¼                  â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Frame Number  â”‚   Offset       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚           Physical Address                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pros:** Table size = number of frames (constant)
**Cons:** Search time (use hash to speed up)

---

## ğŸ“ Segmentation

### Concept

**Divide program into logical units:**
- Main program
- Functions
- Stack
- Symbol table
- etc.

```
Logical View:                Physical Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Segment 0    â”‚          â”‚                        â”‚
â”‚   (Main)       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â–º Segment 0 (at 1400)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Segment 1    â”‚          â”‚                        â”‚
â”‚   (Function)   â”‚â”€â”€â”       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚       â”‚                        â”‚
â”‚   Segment 2    â”‚  â”‚       â”‚                        â”‚
â”‚   (Stack)      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¤â–º Segment 1 (at 4300)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                            â”‚                        â”‚
                            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                            â”‚â–º Segment 2 (at 6700)   â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Segment Table

```
Logical Address: (segment number, offset)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Segment Table                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Seg # â”‚  Limit  â”‚    Base      â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚   0   â”‚  1000   â”‚    1400      â”‚    â”‚
â”‚  â”‚   1   â”‚  400    â”‚    4300      â”‚    â”‚
â”‚  â”‚   2   â”‚  600    â”‚    6700      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Address Translation:
if (offset < limit[segment])
    Physical Address = base[segment] + offset
else
    Trap (segment fault)
```

---

### Paging vs Segmentation

| Aspect | Paging | Segmentation |
|--------|--------|--------------|
| **Size** | Fixed (power of 2) | Variable |
| **Division** | Physical | Logical |
| **Address** | Single (page + offset) | Two (segment + offset) |
| **Fragmentation** | Internal | External |
| **Table** | Page table | Segment table |
| **Sharing** | Harder | Easier (share segments) |
| **Protection** | Page level | Segment level |

---

## ğŸ”€ Segmentation with Paging

**Best of both worlds:** Segment pages

```
Logical Address:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Segment   â”‚   Page     â”‚   Offset    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚            â”‚             â”‚
      â–¼            â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚             â”‚
â”‚Segment Table â”‚   â”‚             â”‚
â”‚  â†’ Page Tbl  â”‚â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚         â”‚   â”‚
                   â–¼         â–¼   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
            â”‚  Page Table  â”‚     â”‚
            â”‚  â†’ Frame     â”‚â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â–º Physical Address
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
                                 â–¼
```

**Intel x86 (Protected Mode):** Uses this approach

---

## ğŸ”’ Memory Protection

### Protection via Paging

```
Page Table Entry:
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Validâ”‚ Read â”‚Write â”‚    Frame Number     â”‚
â”‚  bit â”‚ bit  â”‚ bit  â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Hardware checks on EVERY access:
1. Valid bit = 1?
2. Operation allowed (R/W/X)?
3. Privilege level correct?
```

---

### Shared Pages

**Reentrant Code:** Code that doesn't modify itself; can be shared

```
Process A:           Shared:         Process B:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Data A    â”‚       â”‚ Shared    â”‚   â”‚ Data B    â”‚
â”‚ (private) â”‚       â”‚ Code      â”‚   â”‚ (private) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ (libc)    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚             â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜         â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                    â”‚  Frame 5  â”‚ â† Shared code in memory only once
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Example:** 40 processes using editor
- Without sharing: 40 Ã— (Code + Data)
- With sharing: 1 Ã— Code + 40 Ã— Data

---

## ğŸ“ GATE PYQ Patterns

### Common Question Types:
1. **Address translation:** Calculate physical from logical
2. **Page table size:** Calculate entries and bytes
3. **EAT calculation:** With TLB hit ratio
4. **Fragmentation:** Internal vs External
5. **Page faults:** (covered in Virtual Memory)

### âš ï¸ Edge Cases & Traps:
1. **Page table entry size â‰  frame number bits** (includes protection bits)
2. **Internal fragmentation avg = page size / 2**
3. **TLB flush on context switch** (unless ASID used)
4. **Multi-level paging** - calculate ALL table sizes

---

## ğŸ¯ Quick Revision Points

```
âœ“ Logical address â†’ MMU â†’ Physical address
âœ“ Paging: Fixed pages, frames; no external fragmentation
âœ“ Segmentation: Variable sizes; logical division
âœ“ Internal fragmentation: Paging (last page)
âœ“ External fragmentation: Segmentation, variable partition
âœ“ TLB: Hardware cache for page table
âœ“ EAT = Î± Ã— hit_time + (1-Î±) Ã— miss_time
âœ“ Multi-level paging: Page the page table
âœ“ Inverted page table: Entry per frame, not page
âœ“ Compaction: Solve external fragmentation (expensive)
```

---

## ğŸ“š Key Formulas

```
Page Number = Logical Address / Page Size
Offset = Logical Address mod Page Size
Physical Address = (Frame Number Ã— Page Size) + Offset

Number of Pages = Logical Address Space / Page Size
Number of Frames = Physical Memory / Page Size
Page Table Size = Number of Pages Ã— Entry Size

EAT = Î±(TLB + Mem) + (1-Î±)(TLB + 2Ã—Mem)
    â‰ˆ m(2 - Î±) when TLB time negligible

Internal Fragmentation (avg) = Page Size / 2

For n-level paging:
Memory accesses = n + 1 (without TLB)
```

---

[â† Previous: Deadlocks](./05-Deadlocks.md) | [Next: Virtual Memory â†’](./07-Virtual-Memory.md)
