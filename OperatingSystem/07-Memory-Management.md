# Chapter 7: Memory Management

## ğŸ¯ The Atomic Truth
> **Memory Management = Address Translation + Space Allocation + Protection**

---

## ğŸ§  The WHY of Memory Management

### The Problem
- Programs need memory to run
- Multiple programs run simultaneously
- Physical memory is limited
- Programs don't know where they'll be loaded

### The Solution
```
MEMORY MANAGER'S JOB:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. ALLOCATION: Give memory to processes                      â”‚
â”‚ 2. TRANSLATION: Convert logical â†’ physical addresses         â”‚
â”‚ 3. PROTECTION: Prevent illegal access                        â”‚
â”‚ 4. SHARING: Allow controlled sharing                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Address Binding

### When Addresses are Bound

| Stage | Binding Type | Flexibility | Example |
|-------|--------------|-------------|---------|
| **Compile Time** | Absolute | None (fixed location) | MS-DOS .COM files |
| **Load Time** | Relocatable | Once (at load) | Static relocation |
| **Execution Time** | Dynamic | Full (can move) | Modern systems |

### Logical vs Physical Address

| Address Type | What it is | Who sees it |
|--------------|------------|-------------|
| **Logical (Virtual)** | Generated by CPU | Process |
| **Physical** | Actual RAM location | Memory hardware |

**The Hardware Translator: MMU (Memory Management Unit)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      Logical       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      Physical      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CPU    â”‚ â”€â”€â”€â”€â”€â”€Addressâ”€â”€â”€â”€â†’ â”‚   MMU    â”‚ â”€â”€â”€â”€â”€Addressâ”€â”€â”€â”€â”€â†’ â”‚  Memory  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚
                              Translation
```

---

## ğŸ  Contiguous Memory Allocation

### Fixed Partitioning

**Memory divided into fixed-size partitions.**

```
MEMORY MAP:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         OS              â”‚ Fixed (can't change)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 1 (2MB)   â”‚ 
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 2 (4MB)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 3 (3MB)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Partition 4 (6MB)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problem: Internal Fragmentation**
- Process = 3MB, Partition = 4MB
- Wasted = 1MB INSIDE partition

### Variable Partitioning

**Partitions created dynamically based on process size.**

```
INITIAL:                    AFTER ALLOCATIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        OS         â”‚      â”‚        OS         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   â”‚      â”‚   Process A (5MB) â”‚
â”‚                   â”‚      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    FREE (20MB)    â”‚  â†’   â”‚   Process B (3MB) â”‚
â”‚                   â”‚      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   â”‚      â”‚   FREE (12MB)     â”‚
â”‚                   â”‚      â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problem: External Fragmentation**
- Total free = 12MB (enough for 10MB process)
- But scattered in small chunks

---

## ğŸ“¦ Dynamic Memory Allocation Strategies

### First Fit
**Allocate first hole big enough.**

```
Holes: [5MB] â†’ [10MB] â†’ [3MB] â†’ [8MB]
Request: 7MB

First Fit: Uses [10MB] hole â†’ Leaves 3MB fragment
```

### Best Fit
**Allocate smallest hole that fits.**

```
Holes: [5MB] â†’ [10MB] â†’ [3MB] â†’ [8MB]
Request: 7MB

Best Fit: Uses [8MB] hole â†’ Leaves 1MB fragment
```

### Worst Fit
**Allocate largest hole.**

```
Holes: [5MB] â†’ [10MB] â†’ [3MB] â†’ [8MB]
Request: 7MB

Worst Fit: Uses [10MB] hole â†’ Leaves 3MB (larger fragment, might be useful)
```

### Comparison

| Algorithm | Speed | Fragmentation | Best Use |
|-----------|-------|---------------|----------|
| **First Fit** | Fast | Medium | General purpose |
| **Best Fit** | Slow (search all) | Many tiny fragments | Known request sizes |
| **Worst Fit** | Slow | Large fragments | Varied request sizes |

**GATE Fact**: First Fit and Best Fit are generally better than Worst Fit.

---

## ğŸ§© Fragmentation

### Internal Fragmentation
**Wasted space INSIDE allocated partition.**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Partition: 4KB        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Process: 3.5KB   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  [Wasted: 0.5KB]       â”‚  â† INTERNAL
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### External Fragmentation
**Wasted space OUTSIDE (between) allocations.**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   P1   â”‚ HOLE â”‚   P2   â”‚ HOLE â”‚   P3   â”‚
â”‚  3MB   â”‚ 1MB  â”‚  2MB   â”‚ 2MB  â”‚  4MB   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total holes = 3MB (can't fit 3MB process - not contiguous!)
```

### Solutions

| Fragmentation | Solution |
|---------------|----------|
| Internal | Use smaller allocation units |
| External | Compaction or Paging |

**Compaction**: Move processes to create one large free block.
- **Cost**: High (need to move data)
- **Requirement**: Execution-time binding

---

## ğŸ“„ Paging

### The WHY

**Problem**: External fragmentation wastes memory.
**Solution**: Don't require contiguous allocation!

### How Paging Works

```
LOGICAL MEMORY:              PHYSICAL MEMORY:
(Process View)               (Actual RAM)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Page 0    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚   Frame 5   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Page 1    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚   Frame 2   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Page 2    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚   Frame 8   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Page 3    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚   Frame 1   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Process sees contiguous pages (0,1,2,3)
But they're in random frames (5,2,8,1)
```

### Key Definitions

| Term | Definition |
|------|------------|
| **Page** | Fixed-size block in logical memory |
| **Frame** | Fixed-size block in physical memory |
| **Page Size** | Size of page = Size of frame |

**Common page sizes**: 4KB, 8KB, 4MB (large pages)

### Address Translation

```
LOGICAL ADDRESS (32-bit, 4KB pages):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Page Number (p)  â”‚   Page Offset (d)  â”‚
â”‚      20 bits       â”‚      12 bits       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Page number â†’ Look up in PAGE TABLE â†’ Frame number
Offset stays same (position within page)

PHYSICAL ADDRESS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frame Number (f) â”‚   Page Offset (d)  â”‚
â”‚      20 bits       â”‚      12 bits       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Formula for Address Parts

Given:
- Logical address space = $2^m$ bytes
- Page size = $2^n$ bytes

Then:
- Page offset bits = $n$
- Page number bits = $m - n$
- Number of pages = $2^{m-n}$

**Example**: 32-bit address, 4KB pages (2Â¹Â² bytes)
- Offset = 12 bits
- Page number = 32 - 12 = 20 bits
- Total pages = 2Â²â° = 1M pages

---

## ğŸ“‹ Page Table

### Structure

```
PAGE TABLE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Page Number â”‚ Frame Number â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     0       â”‚      5       â”‚
â”‚     1       â”‚      2       â”‚
â”‚     2       â”‚      8       â”‚
â”‚     3       â”‚      1       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Page Table Entry (PTE) Contents

| Field | Bits | Purpose |
|-------|------|---------|
| **Frame number** | Varies | Physical frame |
| **Present/Valid** | 1 | Is page in memory? |
| **Protection** | 2-3 | Read/Write/Execute |
| **Modified (Dirty)** | 1 | Has page been written? |
| **Referenced** | 1 | Has page been accessed? |
| **Caching** | 1 | Disable caching? |

### Page Table Size Problem

**Problem**: Page table itself can be huge!

**Example**: 
- 32-bit address, 4KB pages
- Pages = 2Â²â° = 1M entries
- Each entry = 4 bytes
- **Page table = 4MB per process!**

For 64-bit systems, it's astronomically worse.

---

## ğŸ—ï¸ Page Table Structures

### 1. Hierarchical (Multi-level) Page Tables

**Solution**: Page the page table!

```
TWO-LEVEL PAGE TABLE (32-bit):

Logical Address:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  P1 (10) â”‚  P2 (10) â”‚ d (12)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚           â”‚         â”‚
     â†“           â”‚         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚         â”‚
â”‚ Outer   â”‚      â”‚         â”‚
â”‚ Page    â”‚      â”‚         â”‚
â”‚ Table   â”‚      â”‚         â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â”‚         â”‚
     â”‚           â†“         â”‚
     â””â”€â”€â”€â”€â”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
             â”‚ Inner   â”‚   â”‚
             â”‚ Page    â”‚   â”‚
             â”‚ Table   â”‚   â”‚
             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â”‚
                  â”‚        â”‚
                  â†“        â†“
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Physical Frame  â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Advantage**: Only allocate inner tables as needed.

### 2. Hashed Page Tables

**For sparse address spaces (64-bit).**

```
Virtual Page Number â†’ Hash Function â†’ Hash Table Entry

Hash Table Entry:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Virtual Page | Frame Number | Pointer to Next  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Inverted Page Table

**One entry per PHYSICAL frame (not per logical page).**

```
INVERTED PAGE TABLE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frame Number â”‚ Process ID  â”‚ Page Number  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      0       â”‚    P1       â”‚     3        â”‚
â”‚      1       â”‚    P2       â”‚     0        â”‚
â”‚      2       â”‚    P1       â”‚     1        â”‚
â”‚     ...      â”‚    ...      â”‚    ...       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Size = Number of frames (not number of pages!)
```

**Problem**: Search required for address translation.
**Solution**: Use hash table.

---

## âš¡ Translation Lookaside Buffer (TLB)

### The Problem

Paging adds overhead: Every memory access needs PAGE TABLE lookup first!

**Without TLB**: 2 memory accesses (page table + actual data)

### The Solution: TLB

**TLB = Cache for page table entries.**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          MMU                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                         TLB                            â”‚  â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚  â”‚
â”‚  â”‚   â”‚ Page Num   â”‚ Frame Num     â”‚  (Fast! ~1 cycle)     â”‚  â”‚
â”‚  â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”‚  â”‚
â”‚  â”‚   â”‚    5       â”‚     42        â”‚                       â”‚  â”‚
â”‚  â”‚   â”‚   12       â”‚     37        â”‚                       â”‚  â”‚
â”‚  â”‚   â”‚    7       â”‚     21        â”‚                       â”‚  â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â†“ Miss                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              PAGE TABLE (in memory)                    â”‚  â”‚
â”‚  â”‚                    (Slow! ~100 cycles)                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Effective Access Time (EAT)

$$EAT = h \times (TLB + Memory) + (1-h) \times (TLB + 2 \times Memory)$$

Where:
- $h$ = TLB hit rate
- $TLB$ = TLB access time
- $Memory$ = Memory access time

**Simplified** (if TLB time negligible):
$$EAT = h \times M + (1-h) \times 2M = M(2 - h)$$

**Example**: Memory = 100ns, TLB = 10ns, Hit rate = 98%

$$EAT = 0.98 \times (10 + 100) + 0.02 \times (10 + 200)$$
$$= 0.98 \times 110 + 0.02 \times 210$$
$$= 107.8 + 4.2 = 112 \text{ ns}$$

---

## ğŸ“ Segmentation

### The WHY

**Problem with Paging**: Logical view is flat (just pages).
**Reality**: Programs have structure (code, data, stack, heap).

**Segmentation**: Divide memory by logical units.

```
PROGRAMMER'S VIEW:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Segment 0: CODE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Segment 1: GLOBAL DATA                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Segment 2: HEAP                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Segment 3: STACK                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Segment 4: SHARED LIBRARY               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Segment Table

```
SEGMENT TABLE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Segment #   â”‚ Base Address  â”‚ Limit (Size) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     0       â”‚    1400       â”‚     400      â”‚
â”‚     1       â”‚    6300       â”‚     100      â”‚
â”‚     2       â”‚    4700       â”‚     500      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Address Translation

```
Logical Address = (Segment Number, Offset)

Translation:
1. Look up segment s in segment table
2. Check: offset < limit (else TRAP - protection fault)
3. Physical Address = Base + Offset
```

### Paging vs Segmentation

| Aspect | Paging | Segmentation |
|--------|--------|--------------|
| **Division** | Fixed size | Variable size |
| **View** | Physical (frames) | Logical (modules) |
| **Fragmentation** | Internal | External |
| **Sharing** | By page | By segment (easier) |
| **Protection** | Per page | Per segment (meaningful) |

---

## ğŸ”„ Segmentation with Paging

**Best of both: Segment the logical space, page each segment.**

```
SEGMENTED PAGED MEMORY:

Logical Address:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Segment #  â”‚ Page #     â”‚ Offset     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚            â”‚            â”‚
      â†“            â”‚            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            â”‚
â”‚ Segment     â”‚    â”‚            â”‚
â”‚ Table       â”‚    â”‚            â”‚
â”‚ (Baseâ†’PT)   â”‚    â”‚            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            â”‚
      â”‚            â†“            â”‚
      â””â”€â”€â”€â”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
             â”‚ Page Table  â”‚    â”‚
             â”‚ for segment â”‚    â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                   â”‚            â”‚
                   â†“            â†“
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚   Physical Frame   â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Example**: Intel x86 (32-bit) used segmentation + paging.

---

## ğŸ§® GATE Numerical Examples

### Example 1: Page Table Size

**Given**: 
- Virtual address: 32 bits
- Page size: 4KB
- PTE size: 4 bytes

**Find**: Page table size

**Solution**:
- Page size = 4KB = 2Â¹Â² bytes
- Offset bits = 12
- Page number bits = 32 - 12 = 20
- Number of pages = 2Â²â°
- Page table size = 2Â²â° Ã— 4 bytes = 4MB

---

### Example 2: Physical Address Calculation

**Given**:
- Logical address: 0x00003ABC
- Page size: 4KB (0x1000)
- Page table: Page 3 â†’ Frame 7

**Find**: Physical address

**Solution**:
- Offset = 0xABC (last 12 bits)
- Page number = 0x00003 = 3
- Frame number = 7 = 0x007
- Physical address = 0x007ABC

---

### Example 3: EAT with TLB

**Given**:
- TLB hit rate: 90%
- TLB access: 20ns
- Memory access: 100ns

**Find**: EAT

**Solution**:
- Hit: TLB + Memory = 20 + 100 = 120ns
- Miss: TLB + Memory + Memory = 20 + 100 + 100 = 220ns
- EAT = 0.9 Ã— 120 + 0.1 Ã— 220 = 108 + 22 = **130ns**

---

## ğŸ¯ GATE Traps and Anti-Solutions

### Trap 1: Internal vs External
- **Paging**: Internal fragmentation (last page)
- **Segmentation**: External fragmentation

### Trap 2: Page Table Location
- Page table is in MAIN MEMORY (not TLB)
- TLB is a CACHE for page table

### Trap 3: Offset Size
- Offset bits = logâ‚‚(page size)
- Same bits for page and frame offset

### Trap 4: Multi-level Page Table
- Doesn't reduce total entries
- Reduces memory needed if address space sparse

---

## ğŸ“ GATE Previous Year Questions

### Q1: (GATE 2019)
**32-bit virtual address, 4KB pages, 4-byte PTE. Page table size?**

Answer: 2Â²â° Ã— 4 = 4MB

### Q2: (GATE 2018)
**Which causes internal fragmentation?**

(A) Segmentation  
(B) Paging âœ“  
(C) Swapping  
(D) Compaction

### Q3: (GATE 2017)
**TLB hit ratio 95%, TLB time 10ns, Memory 200ns. EAT?**

Hit: 10 + 200 = 210ns
Miss: 10 + 200 + 200 = 410ns
EAT = 0.95 Ã— 210 + 0.05 Ã— 410 = 199.5 + 20.5 = **220ns**

---

## âš¡ The 5-Second Snap-Check

1. **Page table size?** â†’ Pages Ã— PTE size
2. **Physical address?** â†’ Replace page# with frame#, keep offset
3. **EAT?** â†’ Hit(TLB+Mem) + Miss(TLB+2Mem)
4. **Fragmentation?** â†’ Paging=Internal, Segmentation=External

---

## ğŸ† Chapter Summary

| Concept | Key Point |
|---------|-----------|
| Paging | Fixed-size, eliminates external fragmentation |
| Segmentation | Variable-size, logical division |
| Page Table | Maps pages to frames |
| TLB | Cache for page table entries |
| Internal Frag | Wasted inside allocation (paging) |
| External Frag | Wasted between allocations (segmentation) |
| Multi-level PT | Hierarchical to save space |
| EAT | h(TLB+M) + (1-h)(TLB+2M) |

---

*Next Chapter: [Virtual Memory â†’](08-Virtual-Memory.md)*

---

*Logic Singularity verified for 2026 (IIT-G Standards). Mastery Level: Sovereign.*
