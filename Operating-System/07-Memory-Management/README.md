# ğŸ“– Chapter 7: Memory Management

> **The Atomic Truth:** Memory Management = Map logical addresses to physical memory

---

## ğŸ¯ GATE Syllabus Coverage
- Contiguous Memory Allocation
- Paging
- Segmentation
- Fragmentation
- Page Tables
- Address Translation

---

## 7.1 Memory Management Basics

### Memory Hierarchy
```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”
          â”‚  CPU  â”‚
          â”‚Registersâ”‚ â† Fastest, smallest
          â””â”€â”€â”€â”¬â”€â”€â”€â”˜
              â†“
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Cache â”‚ â† Very fast, small
          â””â”€â”€â”€â”¬â”€â”€â”€â”˜
              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚Main RAM â”‚ â† Fast, medium
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â†“
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Disk    â”‚ â† Slow, large
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Address Types

| Type | Definition | Generated By |
|------|------------|--------------|
| **Logical/Virtual** | Address seen by CPU | Program |
| **Physical** | Actual memory address | MMU translation |

### Address Binding

| Binding Time | When | Relocatable? |
|--------------|------|--------------|
| **Compile time** | Compilation | No (absolute code) |
| **Load time** | Loading into memory | Yes (relocatable code) |
| **Execution time** | During execution | Yes (needs hardware support) |

---

## 7.2 Contiguous Memory Allocation

### Fixed Partitioning

Memory divided into fixed-size partitions.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OS (400K)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Partition 1     â”‚
â”‚   (100K)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Partition 2     â”‚
â”‚   (200K)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Partition 3     â”‚
â”‚   (300K)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Partition 4     â”‚
â”‚   (250K)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problems:**
- Internal fragmentation (wasted space within partition)
- Limited multiprogramming degree
- Large processes may not fit

### Variable Partitioning

Partitions created dynamically based on process size.

**Allocation Strategies:**

| Strategy | Method | Speed | Fragmentation |
|----------|--------|-------|---------------|
| **First Fit** | First hole that fits | Fast | Medium |
| **Best Fit** | Smallest hole that fits | Slow | Most small holes |
| **Worst Fit** | Largest hole | Fast | Large holes |
| **Next Fit** | First fit from last position | Fast | Distributes holes |

### First Fit Example
```
Holes: [100K, 500K, 200K, 300K, 600K]
Request: 212K

First Fit: Uses 500K hole â†’ [100K, 288K, 200K, 300K, 600K]
Best Fit:  Uses 300K hole â†’ [100K, 500K, 200K, 88K, 600K]
Worst Fit: Uses 600K hole â†’ [100K, 500K, 200K, 300K, 388K]
```

### Fragmentation

| Type | Definition | Caused By | Solution |
|------|------------|-----------|----------|
| **Internal** | Unused space inside allocation | Fixed partitions, Paging | Variable partitions |
| **External** | Total free memory exists but not contiguous | Variable partitions | Compaction, Paging |

### Compaction
Move processes to eliminate holes. Expensive operation.

```
Before Compaction:        After Compaction:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OS    â”‚               â”‚   OS    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   P1    â”‚               â”‚   P1    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Hole   â”‚               â”‚   P2    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   P2    â”‚               â”‚   P3    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Hole   â”‚               â”‚         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚  Large  â”‚
â”‚   P3    â”‚               â”‚  Hole   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚         â”‚
â”‚  Hole   â”‚               â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7.3 Paging

### Concept
- Divide physical memory into fixed-size **frames**
- Divide logical memory into same-size **pages**
- Map pages to frames using **page table**

**No external fragmentation!** (but internal fragmentation possible in last page)

### Page Size Trade-off

| Small Pages | Large Pages |
|-------------|-------------|
| Less internal fragmentation | More internal fragmentation |
| Larger page table | Smaller page table |
| More page faults | Fewer page faults |

**Typical size:** 4KB - 16KB

### Address Translation

```
Logical Address
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Page Number (p)  â”‚  Page Offset (d) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Page Table   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ p â†’ f    â”‚ â”‚ â†’ Frame number f
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â†“
Physical Address
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Frame Number (f) â”‚  Frame Offset (d)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Address Calculation

$$\text{Page Size} = 2^d \text{ bytes (where d = offset bits)}$$

$$\text{Page Number} = \lfloor \frac{\text{Logical Address}}{\text{Page Size}} \rfloor$$

$$\text{Offset} = \text{Logical Address} \mod \text{Page Size}$$

$$\text{Physical Address} = \text{Frame Number} \times \text{Page Size} + \text{Offset}$$

### Example

**Given:**
- Logical address space: 16 bits (64KB)
- Page size: 4KB = 2Â¹Â² bytes
- Physical memory: 32KB

**Calculate:**
- Page offset bits: 12 (since 4KB = 2Â¹Â²)
- Page number bits: 16 - 12 = 4 â†’ 16 pages
- Frame offset bits: 12
- Frame number bits: logâ‚‚(32KB/4KB) = logâ‚‚(8) = 3

**Address Translation:**
Logical address: 13500

1. Page number = 13500 / 4096 = 3
2. Offset = 13500 mod 4096 = 1212
3. If page 3 maps to frame 5:
   Physical address = 5 Ã— 4096 + 1212 = 21692

---

## 7.4 Page Table Structure

### Single-Level Page Table

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Page Number (20) â”‚ Offset (12)    â”‚  32-bit address, 4KB pages
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Page Table (2Â²â° entries)  â”‚  4MB for table!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problem:** Huge page tables for large address spaces.

### Two-Level (Hierarchical) Paging

```
Logical Address (32 bits)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Outer Page (10) â”‚ Inner Page (10) â”‚ Offset (12)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚
        â†“                 â†“
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Outer PT â”‚ â”€â”€â†’ â”‚ Inner PT â”‚ â”€â”€â†’ Frame
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Advantage:** Only allocate page tables for used address space.

### Inverted Page Table

One entry per physical frame (not per page).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Process ID â”‚ Page Number â”‚ Offset   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚
        â†“           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Inverted Page Table            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Frameâ”‚ PID  â”‚ Page Number    â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  0  â”‚ P1   â”‚     5          â”‚  â”‚
â”‚  â”‚  1  â”‚ P2   â”‚     3          â”‚  â”‚
â”‚  â”‚  2  â”‚ P1   â”‚     2          â”‚  â”‚
â”‚  â”‚ ... â”‚ ...  â”‚    ...         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Advantage:** Fixed size = Number of frames
**Disadvantage:** Slow lookup (must search entire table)
**Solution:** Use hash table

### Hashed Page Table

```
Virtual Page Number
        â”‚
        â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Hash   â”‚
    â”‚Functionâ”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Hash Table                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Indexâ”‚ VPN     â”‚ Frame â”‚ Nextâ”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  h  â”‚   p     â”‚   f   â”‚  â†’  â”‚  â”‚ Chain for collisions
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7.5 Translation Lookaside Buffer (TLB)

### Concept
**TLB** is a fast hardware cache of page table entries.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CPU                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Logical Address: [Page Number | Offset]         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â†“                       â†“
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   TLB    â”‚           â”‚  Page Table  â”‚
      â”‚ (Fast)   â”‚           â”‚   (Memory)   â”‚
      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                        â”‚
     TLB Hit                   TLB Miss
     (fast)                    (slow + update TLB)
           â”‚                        â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
              Frame Number + Offset
                      â”‚
                      â†“
              Physical Address
```

### Effective Access Time (EAT)

$$\boxed{\text{EAT} = h \times T_{TLB+M} + (1-h) \times T_{TLB+2M}}$$

Where:
- $h$ = TLB hit ratio
- $T_{TLB}$ = TLB access time
- $T_M$ = Memory access time

**Simplified (if TLB time is negligible):**
$$\text{EAT} = h \times T_M + (1-h) \times 2T_M = T_M(2-h)$$

### EAT Example

**Given:**
- Memory access time: 100ns
- TLB access time: 20ns
- TLB hit ratio: 95%

**Calculate EAT:**
$$\text{EAT} = 0.95 \times (20 + 100) + 0.05 \times (20 + 200)$$
$$= 0.95 \times 120 + 0.05 \times 220$$
$$= 114 + 11 = 125\text{ns}$$

**Without TLB:** 200ns (need 2 memory accesses)
**Speedup:** 200/125 = 1.6x

### TLB Entry Structure

| Field | Description |
|-------|-------------|
| Page Number | Virtual page |
| Frame Number | Physical frame |
| ASID | Address Space ID (for context switch) |
| Valid | Entry is valid |
| Dirty | Page modified |
| Access bits | R/W/X permissions |

---

## 7.6 Page Table Entry (PTE) Bits

| Bit | Name | Purpose |
|-----|------|---------|
| V | Valid/Present | Page in memory? |
| M | Modified/Dirty | Page written to? |
| R | Referenced | Page accessed recently? |
| P | Protection | Read/Write/Execute |
| C | Cache Disable | Disable caching |

---

## 7.7 Segmentation

### Concept
Memory divided into logical segments (code, data, stack, etc.)

```
User View of Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Stack     â”‚ Segment 0
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Main      â”‚ Segment 1
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Sqrt      â”‚ Segment 2
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Symbol    â”‚ Segment 3
â”‚   Table     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Physical Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stack â”‚     â”‚ Main â”‚ Symbol â”‚ Sqrt  â”‚
â”‚  (0)  â”‚     â”‚  (1) â”‚   (3)  â”‚  (2)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   Segments placed anywhere
```

### Segment Table

| Segment | Base | Limit |
|---------|------|-------|
| 0 | 1400 | 1000 |
| 1 | 6300 | 400 |
| 2 | 4300 | 400 |
| 3 | 3200 | 1100 |

### Address Translation

```
Logical Address
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Segment Number (s) â”‚ Offset (d) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚               â”‚
         â†“               â”‚
    Segment Table        â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”      â”‚
    â”‚ Base â”‚Limit â”‚      â”‚
    â””â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”¬â”€â”€â”€â”˜      â”‚
       â”‚      â”‚          â”‚
       â†“      â†“          â†“
    [if d < limit: valid]
       â”‚
Physical Address = Base + d
```

### Segmentation vs Paging

| Feature | Paging | Segmentation |
|---------|--------|--------------|
| Division | Fixed size | Variable size |
| User view | Invisible | Visible (logical units) |
| Fragmentation | Internal | External |
| Table size | Large | Small |
| Sharing | At page level | At segment level (natural) |

---

## 7.8 Segmentation with Paging

### Intel IA-32 (Legacy)

```
Logical Address
     â”‚
     â†“
 Segmentation
     â”‚
     â†“
Linear Address
     â”‚
     â†“
   Paging
     â”‚
     â†“
Physical Address
```

**Segment + Page:** Best of both worlds
- Logical view (segments)
- No external fragmentation (paging)

---

## 7.9 Page Table Size Calculation

### Formula

$$\text{Page Table Size} = \text{Number of Pages} \times \text{Entry Size}$$

$$\text{Number of Pages} = \frac{\text{Virtual Address Space}}{\text{Page Size}}$$

### Example

**Given:**
- 32-bit virtual address
- 4KB page size
- 4 bytes per PTE

**Calculate:**
- Number of pages = 2Â³Â²/2Â¹Â² = 2Â²â° = 1M pages
- Page table size = 1M Ã— 4B = 4MB

**Problem:** Too large for each process!

**Solution:** Multi-level paging, inverted page table

---

## ğŸ¯ GATE PYQ Analysis

### Question 1 (GATE 2018)
**Q:** Page size = 4KB, 32-bit virtual address, 24-bit physical address. How many entries in page table?

**Solution:**
- Page size = 4KB = 2Â¹Â² bytes
- Offset bits = 12
- Virtual page bits = 32 - 12 = 20
- Number of entries = 2Â²â° = 1,048,576

**Answer:** 2Â²â° = 1M entries

---

### Question 2 (GATE 2019)
**Q:** TLB hit ratio = 90%, Memory access = 100ns, TLB access = 10ns. What is EAT?

**Solution:**
- TLB hit: 10 + 100 = 110ns (TLB + 1 memory)
- TLB miss: 10 + 100 + 100 = 210ns (TLB + page table + memory)
- EAT = 0.9 Ã— 110 + 0.1 Ã— 210 = 99 + 21 = 120ns

**Answer:** 120ns

---

### Question 3 (GATE 2020)
**Q:** Which causes external fragmentation?
(a) Paging
(b) Segmentation
(c) Both
(d) Neither

**Answer:** (b) Segmentation

**Explanation:** Segmentation uses variable-size partitions, causing external fragmentation. Paging uses fixed-size frames, no external fragmentation.

---

## ğŸ§  Memory Tricks

### Mnemonic: Paging vs Segmentation
**P**aging = **P**ieces of equal size (fixed)
**S**egmentation = **S**izes vary (variable)

### EAT Formula Memory Hook
"**Hit** is cheap (1 memory), **Miss** is expensive (2 memories)"
$$\text{EAT} = h \times (\text{cheap}) + (1-h) \times (\text{expensive})$$

### Fragmentation Memory Trick
- **I**nternal â†’ **I**nside (fixed blocks, waste inside)
- **E**xternal â†’ **E**verywhere (scattered holes)

### Page Table Entry Bits "VMR PC"
- **V**alid
- **M**odified (dirty)
- **R**eferenced
- **P**rotection
- **C**ache control

---

## âš ï¸ Common GATE Traps

### Trap 1: Offset Bits
**Wrong:** Forgetting offset stays same in logical and physical
**Right:** Offset bits = logâ‚‚(page size), same in both addresses

### Trap 2: EAT Calculation
**Wrong:** Not including TLB time
**Right:** TLB access time adds to both hit and miss cases

### Trap 3: Page Table Size
**Wrong:** Using physical address space size
**Right:** Page table entries = virtual pages = virtual space / page size

### Trap 4: Multi-level Paging Accesses
**Wrong:** Counting only final memory access
**Right:** n-level paging = n+1 memory accesses on TLB miss

---

## ğŸ“ Practice Problems

### Problem 1
Virtual address: 20 bits, Physical: 16 bits, Page size: 1KB
Calculate: (a) Page table entries (b) Frame table entries

### Problem 2
Given EAT = 150ns, Memory access = 100ns, TLB access = 20ns
Find TLB hit ratio.

### Problem 3
Two-level paging: 32-bit VA, 4KB pages, 4B PTE
Outer page: 10 bits, Inner page: 10 bits
How many memory accesses on TLB miss?

---

## ğŸ”— Quick Reference

| Concept | Key Point |
|---------|-----------|
| Paging | Fixed-size, no external fragmentation |
| Segmentation | Variable-size, logical view |
| Internal Frag | Fixed partitions waste space inside |
| External Frag | Variable partitions create holes |
| TLB | Fast cache of page table entries |
| EAT | h Ã— (TLB+M) + (1-h) Ã— (TLB+2M) |
| Page Table Size | (VA Space / Page Size) Ã— Entry Size |

### Formulas

$$\text{Physical Address} = \text{Frame} \times \text{Page Size} + \text{Offset}$$

$$\text{EAT} = h \times T_{hit} + (1-h) \times T_{miss}$$

$$\text{Page Number} = \lfloor \frac{\text{Logical Addr}}{\text{Page Size}} \rfloor$$

---

**Logic Singularity verified for 2026 (IIT-G Standards). Mastery Level: [Sovereign]**

*Next: [Chapter 8 - Virtual Memory](../08-Virtual-Memory/README.md)*
